const functions = require('firebase-functions');
const admin = require('firebase-admin');
const axios = require('axios');

admin.initializeApp();
const db = admin.firestore();

// Importar funciones de admin
const { initializeAppConfig, getAdminStats, isUserAdmin } = require('./admin');

// Exportar funciones de admin
exports.initializeAppConfig = initializeAppConfig;
exports.getAdminStats = getAdminStats;
exports.isUserAdmin = isUserAdmin;

// Configuraci√≥n de Deepseek API
const DEEPSEEK_API_KEY = 'sk-97c8f4c543fa45acabaf02ebcac60f03';
const DEEPSEEK_BASE_URL = 'https://api.deepseek.com/v1';

// URLs de respaldo
const DEEPSEEK_FALLBACK_URLS = [
    'https://api.deepseek.com/v1',
    'https://api.deepseek.com'
];

// Validar configuraci√≥n al inicializar
if (!DEEPSEEK_API_KEY || !DEEPSEEK_API_KEY.startsWith('sk-')) {
    console.error('[INIT] CRITICAL: Invalid Deepseek API key');
    throw new Error('Invalid Deepseek API key configuration');
}

console.log('[INIT] Deepseek API configurado correctamente con URL:', DEEPSEEK_BASE_URL);

// Objeto de traducciones para el prompt
const translations = {
    es: {
        role: "Eres un experto coach en creaci√≥n de contenido para redes sociales.",
        strictInstructions: "Ideas listas para copiar y publicar. Incluir suficientes emojis equilibrados. Seguir formato:",
        ideaFormat: "---IDEA_N---\nGancho Verbal Impactante: [...]\nTexto del Post: [...]\nHashtags: [...]\nLlamada a la Acci√≥n (CTA): [...]\nFormato Visual Sugerido: [...]\n---FIN_IDEA_N---",
        finalPhrase: "---FRASE_FINAL---\n[Frase Motivadora]\n---FIN_FRASE_FINAL---",
        multiPlatform: (platforms) => `Genera 1 idea para cada red social seleccionada: ${platforms.join(', ')}.`,
        singlePlatform: (platform) => `Genera 3 ideas distintas para la red social: ${platform}.`,
        example: "Ejemplo concreto de la respuesta esperada: Generar una idea para Facebook con el copy de 'Informativo o educativo'. El post debe ser sobre 'C√≥mo la IA puede ayudar a los peque√±os negocios'. La respuesta debe ser en espa√±ol. La respuesta de Deepseek debe ser un texto plano con el formato exactamente como se especifica.",
        copyType: "Tipo de Copy: ",
        copyDescription: "Descripci√≥n: "
    },
    en: {
        role: "You are an expert content creation coach for social media.",
        strictInstructions: "Ideas ready to copy and publish. Include balanced emojis. Follow this format:",
        ideaFormat: "---IDEA_N---\nImpactful Verbal Hook: [...]\nPost Text: [...]\nHashtags: [...]\nCall to Action (CTA): [...]\nSuggested Visual Format: [...]\n---FIN_IDEA_N---",
        finalPhrase: "---FRASE_FINAL---\n[Motivational Phrase]\n---FIN_FRASE_FINAL---",
        multiPlatform: (platforms) => `Generate 1 idea for each selected social network: ${platforms.join(', ')}.`,
        singlePlatform: (platform) => `Generate 3 distinct ideas for the social network: ${platform}.`,
        example: "Concrete example of the expected response: Generate one idea for Facebook with the 'Informative or educational' copy type. The post should be about 'How AI can help small businesses'. The response must be in English. The Deepseek response must be plain text with the format exactly as specified.",
        copyType: "Copy Type: ",
        copyDescription: "Description: "
    },
    pt: {
        role: "Voc√™ √© um coach especialista em cria√ß√£o de conte√∫do para redes sociais.",
        strictInstructions: "Ideias prontas para copiar e publicar. Inclua emojis equilibrados suficientes. Siga este formato:",
        ideaFormat: "---IDEA_N---\nGatilho Verbal Impactante: [...]\nTexto do Post: [...]\nHashtags: [...]\nChamada para A√ß√£o (CTA): [...]\nFormato Visual Sugerido: [...]\n---FIN_IDEA_N---",
        finalPhrase: "---FRASE_FINAL---\n[Frase Motivacional]\n---FIN_FRASE_FINAL---",
        multiPlatform: (platforms) => `Gere 1 ideia para cada rede social selecionada: ${platforms.join(', ')}.`,
        singlePlatform: (platform) => `Gere 3 ideias distintas para a rede social: ${platform}.`,
        example: "Exemplo concreto da resposta esperada: Gerar uma ideia para o Facebook com o tipo de copy 'Informativo ou educativo'. O post deve ser sobre 'Como a IA pode ajudar pequenas empresas'. A resposta deve ser em portugu√™s. A resposta do Deepseek deve ser texto simples com o formato exatamente como especificado.",
        copyType: "Tipo de Copy: ",
        copyDescription: "Descri√ß√£o: "
    }
};

const copyTypes = [
    { name: "De beneficio o soluci√≥n", desc: "C√≥mo el producto mejora la vida del cliente." },
    { name: "De novedad o lanzamiento", desc: "Anuncia algo nuevo para atraer atenci√≥n inmediata." },
    { name: "De interacci√≥n o pregunta", desc: "Dise√±ado para generar respuestas de la audiencia." },
    { name: "De urgencia o escasez", desc: "Genera sensaci√≥n de urgencia para actuar." },
    { name: "Informativo o educativo", desc: "Comparte conocimiento √∫til." },
    { name: "Informal", desc: "Tono casual, cercano." },
    { name: "Llamada a la acci√≥n (CTA)", desc: "Motiva acci√≥n directa (comprar, registrarse)." },
    { name: "Narrativo o storytelling", desc: "Cuenta una historia emocional." },
    { name: "Posicionamiento o branding", desc: "Refuerza imagen de marca." },
    { name: "Testimonio o prueba social", desc: "Muestra experiencias positivas de otros usuarios." },
    { name: "T√©cnico o profesional", desc: "Informaci√≥n especializada o t√©cnica." },
    { name: "Venta directa o persuasivo", desc: "Convencimiento directo para cerrar ventas." }
];

// Funci√≥n de prueba para verificar conectividad con Deepseek
// Nuevo endpoint de test avanzado
exports.testDeepseekAdvanced = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    const results = [];

    try {
        console.log('[ADVANCED_TEST] Iniciando test avanzado de Deepseek...');
        
        // Test 1: Conectividad b√°sica
        try {
            const basicResponse = await axios({
                method: 'GET',
                url: 'https://api.deepseek.com',
                timeout: 10000,
                headers: { 'User-Agent': 'Test/1.0' }
            });
            results.push({
                test: 'basic_connectivity',
                success: true,
                status: basicResponse.status,
                message: 'Conectividad b√°sica OK'
            });
        } catch (error) {
            results.push({
                test: 'basic_connectivity',
                success: false,
                error: error.message,
                code: error.code
            });
        }

        // Test 2: Endpoint de modelos
        try {
            const modelsResponse = await axios({
                method: 'GET',
                url: 'https://api.deepseek.com/v1/models',
                headers: {
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                timeout: 10000
            });
            results.push({
                test: 'models_endpoint',
                success: true,
                status: modelsResponse.status,
                message: 'Endpoint de modelos accesible'
            });
        } catch (error) {
            results.push({
                test: 'models_endpoint',
                success: false,
                error: error.message,
                code: error.code,
                status: error.response?.status
            });
        }

        // Test 3: Chat completions
        try {
            const chatResponse = await axios({
                method: 'POST',
                url: 'https://api.deepseek.com/v1/chat/completions',
                headers: {
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                data: {
                    model: "deepseek-chat",
                    messages: [{ role: "user", content: "Responde solo: Test OK" }],
                    max_tokens: 10,
                    temperature: 0.1
                },
                timeout: 15000
            });
            
            results.push({
                test: 'chat_completions',
                success: true,
                status: chatResponse.status,
                message: chatResponse.data.choices[0].message.content,
                usage: chatResponse.data.usage
            });
        } catch (error) {
            results.push({
                test: 'chat_completions',
                success: false,
                error: error.message,
                code: error.code,
                status: error.response?.status,
                data: error.response?.data
            });
        }

        return { 
            success: true, 
            results,
            summary: {
                total_tests: results.length,
                passed: results.filter(r => r.success).length,
                failed: results.filter(r => !r.success).length
            }
        };

    } catch (error) {
        console.error('[ADVANCED_TEST] Error general:', error.message);
        throw new functions.https.HttpsError('internal', `Advanced test failed: ${error.message}`);
    }
});

exports.testDeepseekConnection = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
    }

    try {
        console.log('[TEST] Iniciando prueba de conectividad con Deepseek...');
        
        // Prueba simple con prompt corto
        const testPrompt = "Responde solo: 'Test exitoso'";
        
        const response = await axios({
            method: 'POST',
            url: `${DEEPSEEK_BASE_URL}/chat/completions`,
            headers: {
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                'Content-Type': 'application/json'
            },
            data: {
                model: "deepseek-chat",
                messages: [{ role: "user", content: testPrompt }],
                max_tokens: 50,
                temperature: 0.1
            },
            timeout: 10000
        });

        console.log('[TEST] ‚úÖ Conexi√≥n exitosa:', response.status);
        return { 
            success: true, 
            status: response.status,
            message: response.data.choices[0].message.content,
            apiUrl: DEEPSEEK_BASE_URL
        };

    } catch (error) {
        console.error('[TEST] ‚ùå Error de conectividad:', error.message);
        throw new functions.https.HttpsError('internal', `Connection test failed: ${error.message}`);
    }
});

exports.api = functions.runWith({
    timeoutSeconds: 300, // Aumentado a 5 minutos
    memory: '1GB' // Aumentado a 1GB para mejor rendimiento
}).https.onCall(async (data, context) => {
    // 1. Validaci√≥n inicial m√°s estricta
    console.log('[API] Inicio de funci√≥n con datos:', JSON.stringify(data, null, 2));
    
    if (!context.auth) {
        console.error('[API] Error: Usuario no autenticado');
        throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }
    
    const uid = context.auth.uid;
    console.log('[API] Usuario autenticado:', uid);
    
    // Validaci√≥n de par√°metros
    const { generationMode, socialMedia, keyword, copyType, language = 'es' } = data;
    
    if (!socialMedia || !Array.isArray(socialMedia) || socialMedia.length === 0) {
        console.error('[API] Error: socialMedia inv√°lido', socialMedia);
        throw new functions.https.HttpsError('invalid-argument', 'socialMedia must be a non-empty array');
    }
    
    if (!keyword || typeof keyword !== 'string' || keyword.trim().length === 0) {
        console.error('[API] Error: keyword inv√°lido', keyword);
        throw new functions.https.HttpsError('invalid-argument', 'keyword must be a non-empty string');
    }
    
    if (!copyType || typeof copyType !== 'string') {
        console.error('[API] Error: copyType inv√°lido', copyType);
        throw new functions.https.HttpsError('invalid-argument', 'copyType must be a string');
    }

    console.log('[API] Par√°metros validados correctamente');

    const t = translations[language] || translations.es;
    
    try {
        // 2. Obtener datos del usuario con timeout
        console.log('[API] Obteniendo datos del usuario...');
        const userRef = db.collection('users').doc(uid);
        const appConfigRef = db.collection('appConfig').doc('config');
        
        const [userDoc, appConfigDoc] = await Promise.all([
            userRef.get(),
            appConfigRef.get()
        ]);
        
        const userData = userDoc.exists ? userDoc.data() : {};
        const appConfigData = appConfigDoc.exists ? appConfigDoc.data() : {};
        
        console.log('[API] Datos del usuario obtenidos:', { 
            userExists: userDoc.exists, 
            isPremium: userData.isPremium,
            credits: userData.generationCredits 
        });

        // 3. Evaluaci√≥n de Estado Premium
        const isEffectivePremium = userData.isPremium || appConfigData.isPremiumGlobalActive || appConfigData.isLaunchPromoActive;
        console.log('[API] Estado premium efectivo:', isEffectivePremium);

        // 4. Validaci√≥n de L√≠mites para usuarios gratuitos
        if (!isEffectivePremium) {
            console.log('[API] Validando l√≠mites para usuario gratuito...');
            
            const lastGenerationDate = userData.lastGenerationDate ? userData.lastGenerationDate.toDate() : new Date(0);
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

            if (lastGenerationDate < oneWeekAgo) {
                console.log('[API] Renovando cr√©ditos semanales...');
                await userRef.update({ 
                    generationCredits: 3, 
                    lastGenerationDate: admin.firestore.Timestamp.now() 
                });
                userData.generationCredits = 3;
            }
            
            if (userData.generationCredits <= 0) {
                console.error('[API] Error: Cr√©ditos agotados');
                throw new functions.https.HttpsError('failed-precondition', 'Generation credits exhausted');
            }
            
            // Validaci√≥n de redes sociales para usuarios gratuitos
            const allowedSocial = ["Facebook"];
            if (socialMedia.some(s => !allowedSocial.includes(s))) {
                console.error('[API] Error: Red social no permitida para usuario gratuito');
                throw new functions.https.HttpsError('permission-denied', 'Free users can only use Facebook');
            }

            // Validaci√≥n de tipos de copy para usuarios gratuitos
            const allowedCopyTypes = ["Informativo o educativo", "Informal", "T√©cnico o profesional"];
            if (!allowedCopyTypes.includes(copyType)) {
                console.error('[API] Error: Tipo de copy no permitido para usuario gratuito');
                throw new functions.https.HttpsError('permission-denied', 'Copy type not allowed for free users');
            }
        }
        
        // 5. Construcci√≥n del Prompt ULTRA-OPTIMIZADO
        console.log('[API] Construyendo prompt CORTO...');
        
        const platform = Array.isArray(socialMedia) ? socialMedia[0] : socialMedia;
        const ideaCount = generationMode === 'multi' ? '1 idea' : '2 ideas';
        
        // Prompt minimalista para m√°xima velocidad
        const prompt = `Genera ${ideaCount} para ${platform} sobre "${keyword}" tipo "${copyType}" en ${language === 'es' ? 'espa√±ol' : language}.

Formato EXACTO por idea:
---IDEA_N---
Texto: [texto del post]
Hashtags: [3-5 hashtags]
CTA: [llamada a la acci√≥n]
---FIN_IDEA_N---

S√© conciso y directo.`;

        console.log('[API] Prompt OPTIMIZADO, longitud:', prompt.length);

        // 6. Llamada a Deepseek con timeout m√≠nimo
        console.log('[API] Iniciando llamada R√ÅPIDA a Deepseek...');
        
        const deepseekResponse = await callDeepseekAPI(prompt);
        console.log('[API] ‚úÖ Respuesta Deepseek obtenida');
        
        const parsedIdeas = parseDeepseekResponse(deepseekResponse);
        console.log('[API] Ideas parseadas:', parsedIdeas.length);

        // 7. Validar que tenemos ideas v√°lidas
        if (!parsedIdeas || parsedIdeas.length === 0) {
            console.log('[API] No se generaron ideas v√°lidas, creando fallback...');
            parsedIdeas.push(createFallbackIdea(keyword, copyType));
        }

        // 8. Actualizaci√≥n de la base de datos
        console.log('[API] Actualizando base de datos...');
        await Promise.all([
            userRef.update({
                generationCredits: isEffectivePremium ? userData.generationCredits : Math.max(0, userData.generationCredits - 1),
                lastGenerationDate: admin.firestore.Timestamp.now()
            }),
            db.collection('generations').add({
                userId: uid,
                timestamp: admin.firestore.Timestamp.now(),
                generationDetails: { generationMode, socialMedia, keyword, copyType, language },
                results: parsedIdeas
            })
        ]);

        console.log('[API] Funci√≥n completada exitosamente');
        return { success: true, ideas: parsedIdeas };

    } catch (error) {
        console.error('[API] Error en funci√≥n principal:', error);
        
        // Manejo espec√≠fico de errores
        if (error instanceof functions.https.HttpsError) {
            throw error;
        }
        
        // Error gen√©rico
        const errorMessage = error.message || 'Unknown error occurred';
        console.error('[API] Error detallado:', {
            message: errorMessage,
            stack: error.stack,
            name: error.name,
            code: error.code
        });
        
        throw new functions.https.HttpsError('internal', `Error generating ideas: ${errorMessage}`);
    }
});

// Funci√≥n ultra-optimizada para llamar a Deepseek API
async function callDeepseekAPI(prompt, retries = 1) {
    console.log('[DEEPSEEK] Iniciando llamada OPTIMIZADA - prompt:', prompt.length, 'chars');
    
    for (let attempt = 1; attempt <= retries + 1; attempt++) {
        console.log(`[DEEPSEEK] Intento ${attempt}/${retries + 1}`);
        
        try {
            // Configuraci√≥n ultra-simplificada para m√°xima velocidad
            const requestData = {
                model: "deepseek-chat",
                messages: [{
                    role: "user",
                    content: prompt
                }],
                temperature: 0.5, // Reducido para respuestas m√°s r√°pidas
                max_tokens: 800, // Reducido significativamente
                stream: false
            };

            console.log('[DEEPSEEK] Enviando request...');

            // Configuraci√≥n minimalista para velocidad m√°xima
            const response = await axios({
                method: 'POST',
                url: `${DEEPSEEK_BASE_URL}/chat/completions`,
                headers: {
                    'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                data: requestData,
                timeout: 15000, // Reducido a 15 segundos
                validateStatus: (status) => status === 200
            });
            
            console.log('[DEEPSEEK] ‚úÖ Respuesta OK:', response.status);
            
            const content = response.data?.choices?.[0]?.message?.content;
            if (!content) {
                throw new Error('Sin contenido en respuesta');
            }

            console.log('[DEEPSEEK] ‚úÖ Contenido recibido:', content.length, 'chars');
            return content.trim();

        } catch (error) {
            console.error(`[DEEPSEEK] ‚ùå Error intento ${attempt}:`, error.message);

            if (attempt > retries) {
                if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
                    throw new Error('API timeout - Deepseek tard√≥ demasiado');
                } else if (error.response?.status === 401) {
                    throw new Error('API key inv√°lida');
                } else if (error.response?.status === 429) {
                    throw new Error('Rate limit excedido');
                } else {
                    throw new Error(`API error: ${error.message}`);
                }
            }

            // Espera m√≠nima antes de retry
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

// Funci√≥n para crear idea de fallback
function createFallbackIdea(keyword, copyType) {
    console.log('[FALLBACK] Creando idea de respaldo...');
    
    const fallbackIdeas = {
        "Informativo o educativo": {
            hook: `üìö ¬øSab√≠as que ${keyword} puede transformar tu d√≠a a d√≠a?`,
            postText: `Descubre c√≥mo ${keyword} est√° revolucionando la forma en que trabajamos y vivimos. Te compartimos informaci√≥n valiosa que te ayudar√° a estar al d√≠a con las √∫ltimas tendencias.`,
            hashtags: ['#educacion', '#aprendizaje', '#conocimiento', `#${keyword.toLowerCase().replace(/\s+/g, '')}`],
            cta: 'üëÜ ¬°Comparte si te result√≥ √∫til!',
            visualFormat: 'Infograf√≠a con datos clave y colores profesionales'
        },
        "Informal": {
            hook: `¬°Hola! üëã Hablemos de ${keyword}`,
            postText: `¬øYa probaste ${keyword}? Te cuento mi experiencia y por qu√© creo que vale la pena conocer m√°s sobre este tema. ¬°Me encantar√≠a saber tu opini√≥n!`,
            hashtags: ['#casual', '#conversacion', '#opinion', `#${keyword.toLowerCase().replace(/\s+/g, '')}`],
            cta: 'üí¨ ¬°Cu√©ntame tu experiencia en los comentarios!',
            visualFormat: 'Imagen casual y amigable con tonos c√°lidos'
        },
        "T√©cnico o profesional": {
            hook: `üîß An√°lisis t√©cnico: ${keyword}`,
            postText: `Desde una perspectiva t√©cnica, ${keyword} presenta caracter√≠sticas interesantes que vale la pena analizar. Aqu√≠ tienes un resumen de los aspectos m√°s relevantes.`,
            hashtags: ['#tecnico', '#profesional', '#analisis', `#${keyword.toLowerCase().replace(/\s+/g, '')}`],
            cta: 'üîó ¬øQuieres profundizar en el tema?',
            visualFormat: 'Dise√±o limpio y profesional con gr√°ficos t√©cnicos'
        }
    };

    return fallbackIdeas[copyType] || {
        hook: `‚ú® Descubre ${keyword}`,
        postText: `${keyword} es un tema fascinante que merece nuestra atenci√≥n. Te compartimos una perspectiva interesante sobre este importante asunto.`,
        hashtags: ['#contenido', '#interesante', `#${keyword.toLowerCase().replace(/\s+/g, '')}`],
        cta: 'üëç ¬°Dale like si te gust√≥!',
        visualFormat: 'Imagen atractiva con colores vibrantes'
    };
}
// Funci√≥n ULTRA-SIMPLIFICADA para parsear respuesta
function parseDeepseekResponse(text) {
    console.log('[PARSER] Parsing respuesta:', text.length, 'chars');
    
    if (!text?.trim()) {
        console.error('[PARSER] Texto vac√≠o');
        return [createFallbackIdea('contenido', 'Informativo')];
    }
    
    const ideas = [];
    
    try {
        // Patr√≥n simplificado para el nuevo formato
        const ideaPattern = /---IDEA_(\d+)---\s*Texto:\s*(.*?)\s*Hashtags:\s*(.*?)\s*CTA:\s*(.*?)\s*---FIN_IDEA_\d+---/gis;
        
        let match;
        while ((match = ideaPattern.exec(text)) !== null) {
            const idea = {
                hook: match[2]?.substring(0, 100) || '', 
                postText: match[2] || '',
                hashtags: (match[3] || '').split(/[,\s#]+/).filter(h => h.length > 0).slice(0, 5),
                cta: match[4] || 'Comparte si te gust√≥',
                visualFormat: 'Imagen atractiva'
            };
            
            if (idea.postText.length > 10) {
                ideas.push(idea);
                console.log('[PARSER] ‚úÖ Idea parseada:', ideas.length);
            }
        }
        
        // Si no se encontraron ideas, crear fallback
        if (ideas.length === 0) {
            console.log('[PARSER] No se parsearon ideas, creando fallback...');
            ideas.push({
                hook: '¬°Contenido interesante!',
                postText: text.substring(0, 300) + '...',
                hashtags: ['contenido', 'interesante'],
                cta: 'Comparte si te gust√≥',
                visualFormat: 'Imagen atractiva'
            });
        }
        
    } catch (error) {
        console.error('[PARSER] Error parsing:', error.message);
        ideas.push(createFallbackIdea('contenido', 'Informativo'));
    }
    
    console.log('[PARSER] Total ideas:', ideas.length);
    return ideas;
}
                visualFormat: cleanText(match[6])
            };
            
            // Validar que la idea tenga contenido m√≠nimo
            if (idea.hook && idea.postText) {
                ideas.push(idea);
                console.log(`[PARSER] Idea ${ideas.length} parseada exitosamente`);
            }
        }

        // Si el patr√≥n principal no funcion√≥, intentar parsing alternativo
        if (ideas.length === 0) {
            console.log('[PARSER] Patr√≥n principal fall√≥, intentando parsing alternativo...');
            return parseAlternativeFormat(text);
        }

        // Agregar frase final si existe
        const finalPhrasePattern = /---FRASE_FINAL---\s*(.*?)\s*---FIN_FRASE_FINAL---/s;
        const finalPhraseMatch = text.match(finalPhrasePattern);
        
        if (finalPhraseMatch && ideas.length > 0) {
            ideas[0].finalQuote = cleanText(finalPhraseMatch[1]) || "¬°Sigue creando contenido incre√≠ble!";
        }

        console.log(`[PARSER] Parseo completado: ${ideas.length} ideas extra√≠das`);
        return ideas;

    } catch (error) {
        console.error('[PARSER] Error durante el parseo:', error);
        return parseAlternativeFormat(text);
    }
}

// Funci√≥n auxiliar para limpiar texto
function cleanText(text) {
    if (!text || typeof text !== 'string') return '';
    return text.trim().replace(/\s+/g, ' ').replace(/^\[|\]$/g, '');
}

// Funci√≥n auxiliar para extraer hashtags
function extractHashtags(text) {
    if (!text || typeof text !== 'string') return ['#contenido'];
    
    // Buscar hashtags existentes
    const hashtagsFound = text.match(/#\w+/g) || [];
    
    // Si no hay hashtags, crear algunos basados en el texto
    if (hashtagsFound.length === 0) {
        const words = text.toLowerCase().split(/\s+/).filter(word => 
            word.length > 3 && 
            !['para', 'con', 'por', 'una', 'los', 'las', 'del', 'que'].includes(word)
        );
        
        return words.slice(0, 3).map(word => `#${word}`).concat(['#contenido']);
    }
    
    return hashtagsFound.slice(0, 5); // M√°ximo 5 hashtags
}

// Funci√≥n de parsing alternativo para formatos menos estructurados
function parseAlternativeFormat(text) {
    console.log('[PARSER] Iniciando parsing alternativo...');
    
    const ideas = [];
    const lines = text.split('\n').filter(line => line.trim().length > 10);
    
    let currentIdea = {};
    let ideaCount = 0;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        const lowerLine = line.toLowerCase();
        
        // Detectar inicio de nueva idea
        if (lowerLine.includes('idea') && (lowerLine.includes('1') || lowerLine.includes('2') || lowerLine.includes('3'))) {
            if (Object.keys(currentIdea).length > 1) {
                ideas.push(validateAndCompleteIdea(currentIdea, ideaCount));
                ideaCount++;
            }
            currentIdea = {};
        }
        
        // Extraer componentes
        if (lowerLine.includes('gancho') || lowerLine.includes('hook')) {
            currentIdea.hook = extractContent(line);
        } else if (lowerLine.includes('texto') || lowerLine.includes('post')) {
            currentIdea.postText = extractContent(line);
        } else if (line.includes('#')) {
            currentIdea.hashtags = extractHashtags(line);
        } else if (lowerLine.includes('cta') || lowerLine.includes('acci√≥n')) {
            currentIdea.cta = extractContent(line);
        } else if (lowerLine.includes('visual') || lowerLine.includes('formato')) {
            currentIdea.visualFormat = extractContent(line);
        }
        
        // Si no hemos identificado el componente pero parece contenido √∫til
        else if (!currentIdea.postText && line.length > 30 && !line.includes(':')) {
            currentIdea.postText = line;
        }
    }
    
    // Agregar la √∫ltima idea
    if (Object.keys(currentIdea).length > 1) {
        ideas.push(validateAndCompleteIdea(currentIdea, ideaCount));
    }
    
    // Si a√∫n no tenemos ideas, crear una b√°sica con todo el texto
    if (ideas.length === 0) {
        console.log('[PARSER] No se pudieron extraer ideas estructuradas, creando idea b√°sica...');
        const chunks = text.split('\n\n').filter(chunk => chunk.trim().length > 20);
        
        if (chunks.length > 0) {
            ideas.push({
                hook: "üí° Ideas generadas por IA",
                postText: chunks[0].trim().substring(0, 300) + (chunks[0].length > 300 ? '...' : ''),
                hashtags: ['#contenido', '#ia', '#marketing'],
                cta: "¬øQu√© opinas de esta idea?",
                visualFormat: "Imagen atractiva con texto superpuesto"
            });
        }
    }
    
    console.log(`[PARSER] Parsing alternativo completado: ${ideas.length} ideas`);
    return ideas;
}

// Funci√≥n auxiliar para extraer contenido despu√©s de ":"
function extractContent(line) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) return line.trim();
    return line.substring(colonIndex + 1).trim();
}

// Funci√≥n auxiliar para validar y completar ideas
function validateAndCompleteIdea(idea, index) {
    const completed = {
        hook: idea.hook || `üí° Idea ${index + 1}`,
        postText: idea.postText || "Contenido generado por IA para redes sociales.",
        hashtags: idea.hashtags || ['#contenido', '#redessociales'],
        cta: idea.cta || "¬°Comparte tu opini√≥n!",
        visualFormat: idea.visualFormat || "Imagen atractiva y llamativa"
    };
    
    return completed;
}

// Funciones de administraci√≥n (solo para usuarios con rol de admin)
exports.setPremiumGlobalStatus = functions.https.onCall(async (data, context) => {
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }
    const adminDoc = await db.collection('admins').doc(context.auth.uid).get();
    if (!adminDoc.exists) {
        throw new functions.https.HttpsError('permission-denied', 'You do not have permission to perform this action.');
    }

    const { isPremiumGlobalActive, premiumGlobalEndDate, isLaunchPromoActive } = data;
    const updateData = {
        isPremiumGlobalActive: isPremiumGlobalActive !== undefined ? isPremiumGlobalActive : false,
        premiumGlobalEndDate: premiumGlobalEndDate ? admin.firestore.Timestamp.fromDate(new Date(premiumGlobalEndDate)) : null,
        isLaunchPromoActive: isLaunchPromoActive !== undefined ? isLaunchPromoActive : false
    };

    await db.collection('appConfig').doc('config').set(updateData, { merge: true });
    return { success: true, message: 'App configuration updated successfully.' };
});
